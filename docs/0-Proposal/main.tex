%!TeX spellcheck = en-GB
\documentclass[12pt, a4paper]{article}
\usepackage{mystyle}

\title{
	\vspace{-4ex}
	\LARGE\textbf{Automatic Parallelisation of Rust Programs at Compile Time} \\
	\vspace{1ex}
	\large\textbf{Project Proposal}
	\vspace{-9ex}
}
\date{}

\begin{document}
\maketitle

\section{Problem}
% What is the problem the project will address?
% Needs more than anecdotal notes!
\textcite{kish2002end} claims Moore's Law is dying/dead. Processors have been gaining more and more cores \parencite{geer2005chip}. Parallelising programs to take advantage of the additional cores has some difficulty and often requires the programmer to make significant changes to the source code. It would be much nicer if the programmer could write code as normal, and the parts that can be run in parallel are automatically converted into parallel code.

\section{Approach}
% How am I going to solve this problem?
The only reason this project seems feasible is because of rust.
The rust language has a unique way of managing memory that can guarantee thread safety. I'm going to use and abuse this. I am going to write a compiler plugin which will analyse the abstract syntax tree of another rust program. Any parts of the abstract syntax tree that could be run in parallel would be run in it's own thread.

% How am I going to evaluate my solution to the problem?
I can evaluate the effectiveness of my solution by measuring the speedup of parallelising the program vs the original serial code. I'll look at existing programs written in rust to see any real world impact.

\subsection{Requirements}
% List hardware and software required for the project
\begin{itemize}
	\item A computer to program on
	\item Source code of some rust programs to parallelise
\end{itemize}

\subsection{Timeline}
% Timetable of the different phases of development
% When are these phases going to be completed
\todo{Add estimated dates}\\
\todo{Include non-coding sections}

For the coding part of the project, the main phases are:
\begin{itemize}
	\item Create two plugins, a linter and a syntax extension
	\item Get the linter plugin to
	\begin{itemize}
		\item Analyse the programs statements to see what variables each statement depends on and what variables the statement modifies (if any)
		\item Produce a dependency tree for the entire program based on this analysis
		\item Look for areas in the tree which do not depend on one another, these areas could be run in parallel
		\item Estimate the speed of each statement for the dependency tree
		\item Record the areas that could be changed into a file
	\end{itemize}
	\item Get the syntax extension plugin to
	\begin{itemize}
		\item Read the file the Linter plugin creates
		\item First try one statement in parallel to test it works
		\item Then try to run everything in parallel to test it works
		\item Then only run parts in parallel if it would be faster to run in parallel (maybe compile to if $n < 1000$ then serial else parallel)
	\end{itemize}

\end{itemize}

\subsection{Project Extensions}
% Or show how the project can be reduced if it takes too long
If I'm ahead of schedule with the coding section of this project, I could look into parallelising `if' statements which have a slow condition. Each branch of the `if' would be run in a separate thread using cloned data. When the condition is finally calculated the incorrect branches would need to be deleted. This kind of parallelisation is different from the project plan as some threads are ``thrown away''.

Another possible extension upon the previous extension is to utilise the GPU using CUDA in cases where a large number of threads are doing the exact same task on different data. I feel it is very unlikely that I would have time for this extension, and I'm unsure of how much real world code would be written in such a way that it could be automatically run on the GPU efficiently.

Ideas come from functional languages (like Haskell), compiler optimisation using multi-threading.

\section{Evaluation}
% Why is the chosen solution the best?
% What are the other approaches (and why they are bad)?
% How will I know if the project is a success?
\begin{itemize}
	\item Edit the compiler code directly instead of using a plugin
	\item Use a different language than rust
	\item Make the programmer annotate which parts of the code are parallelisable (like OpenMP)
	\item Don't do anything and just make the programmer worry about parallelisation
\end{itemize}

\textbf{Project Risks:}
\begin{itemize}
	\item Compiler code too complicated to use
	\item Size of task is too large
	\item No idea how to analyse the speed to statements at compile time yet
	\item ``Independent tasks can be run in parallel'' is true in my head, but maybe not in practice
	\item Rust may not give me all the guarantees that I think it would give me

\end{itemize}

\textbf{Downsides to this approach:}\\
The end user programmer would need to:
\begin{itemize}
	\item Add my crate to the Cargo.toml file and import it in main.rs or lib.rs
	\item Compile their program twice (first compile is for analysing, the second is for applying the changes)
	\item Annotate each function to allow the plugin to make changes to the code
\end{itemize}

\section{References}
\printbibliography[heading=none]

\end{document}
