%!TeX spellcheck = en-GB
\documentclass[12pt, a4paper]{article}
\usepackage{mystyle}

\title{
	\vspace{-4ex}
	\LARGE\textbf{Automatic Parallelisation of Rust Programs at Compile Time} \\
	\vspace{1ex}
	\large\textbf{Project Proposal}
	\vspace{-9ex}
}
\date{}

\begin{document}
\maketitle

\section{Problem}
% What is the problem the project will address?
% Needs more than anecdotal notes!
\textcite{kish2002end} estimated the end of Moore's Law of miniaturization within 6-8 years or earlier (based on their publication date) and as such, manufacturers have been increasing processors' core count to increase processor performance \parencite{geer2005chip}. Writing parallelised programs to take advantage of these additional cores has some difficulty and often requires significant changes to the source code. Is it possible to automate these changes to convert sequential code into parallelised code? Previous attempts at solving this problem include \textcite{d1998fortran} where they automated parallelisation of sequential FORTRAN code and \textcite{baskaran2010automatic} where they automated conversion of sequential C into CUDA code. Both of these approaches use unsafe programming languages significant complexity to their solutions. Instead, can this problem be solved more easily with a safe programming language like rust \parencite{rustlang}?

\section{Approach}
% How am I going to solve this problem?
My approach involves writing a plugin for the rust compiler. This plugin would take the abstract syntax tree of the rust program that is being compiled, and analyse what each statement depends on and the statement modifies. This would create a dependency tree, where any two tasks that are independent can be run in parallel.

\todo{Talk about Linter and Syntax Extension, and rust compiler plugin limitations}

\subsection{Requirements}
% List hardware and software required for the project
I believe that I have access to all the required software and hardware for this project. Below is listed most of what I am planning to use:
\begin{itemize}
	\item A computer to program on
	\item Source code of some rust programs to parallelise
	\item Rust compiler (and it's source code)
	\item Atom
\end{itemize}

\subsection{Timeline}
% Timetable of the different phases of development
% When are these phases going to be completed
\todo{Add estimated dates}

Below is an estimated timeline of the project.

\begin{itemize}
	\item Write this proposal
	\item Submit the ethical review
	\item Create two plugins, a linter and a syntax extension
	\begin{itemize}
		\item Get the linter plugin to:
		\begin{itemize}
			\item Analyse the programs statements to see what variables each statement depends on and what variables the statement modifies (if any)
			\item Produce a dependency tree for the entire program based on this analysis
			\item Look for areas in the tree which do not depend on one another, these areas could be run in parallel
			\item Estimate the speed of each statement for the dependency tree
			\item Record the areas that could be changed into a file
		\end{itemize}
		\item Get the syntax extension plugin to:
		\begin{itemize}
			\item Read the file the Linter plugin creates
			\item First try one statement in parallel to test it works
			\item Then try to run everything in parallel to test it works
			\item Then only run parts in parallel if it would be faster to run in parallel (maybe compile to if $n < 1000$ then serial else parallel)
		\end{itemize}
	\end{itemize}
	\item Do some testing
	\item Write a report
\end{itemize}

\subsection{Possible Extensions}
% Or show how the project can be reduced if it takes too long
If I'm ahead of schedule with the coding section of this project, I could look into parallelising `if' statements which have a slow condition. Each branch of the `if' would be run in a separate thread using cloned data. When the condition is finally calculated the incorrect branches would need to be deleted. This kind of parallelisation is different from the project plan as some threads are ``thrown away''.

Another possible extension upon the previous extension is to utilise the GPU using CUDA in cases where a large number of threads are doing the exact same task on different data. I feel it is very unlikely that I would have time for this extension, and I'm unsure of how much real world code would be written in such a way that it could be automatically run on the GPU efficiently.

\section{Evaluation}
\subsection{Disadvantages to the Chosen Approach}
While I think the approach I have chosen is the best option to solve the problem, there are a few downsides to this proposed approach.

To take an existing sequential rust program and compile it requires a few steps. The compiler plugin crate would need to be imported, and every function would need to be annotated so that the plugin has edit access to the abstract syntax tree for that function.

Due to the limitation of rust compiler plugins, the program would need to be compiled twice. The first compile would allow the entire syntax tree to be analysed for parallelisable sections. The second compile would edit the syntax tree to move the parallelisable sections into separate threads.

\textbf{Project Risks:}
\begin{itemize}
	\item Compiler code too complicated to use
	\item Size of task is too large
	\item No idea how to analyse the speed to statements at compile time yet
	\item ``Independent tasks can be run in parallel'' is true in my head, but maybe not in practice
	\item Rust may not give me all the guarantees that I think it would give me
\end{itemize}


% Why is the chosen solution the best?
% What are the other approaches (and why they are bad)?
\subsection{Other Approaches}
There are other approaches to the problem that I am trying to solve (some of which have already been implemented). I will explain these other approaches and why I didn't choose them.

\subsubsection{Make a custom rust compiler}
One of the downsides of the chosen approach is that the program has to be compiled twice. I may be able to bypass this limitation by making a fork of the rust compiler instead of using compiler plugins. It would then be possible to examine the entire abstract syntax tree and then edit it afterwards. However, this approach would add significant complexity to the project as the rust compiler code is very complex.

\subsubsection{Use a different language from rust}
There are many programs out there, written in many different languages. So why rust? Rust is not even in the top 25 of most popular programming languages according to \textcite{stackoverflowsurvey}. Using a more popular language would make this tool more useful for more programs. Rust isn't unpopular as it is the most loved language and the 10th language on the most want to lean list \parencite{stackoverflowsurvey}. The main reason for using rust is the guaranteed memory safety and threads without race conditions which would help significantly with the task.

\subsubsection{Manually annotate the parts of the program that are parallelisable}
\parencite{dagum1998openmp}

\subsubsection{Just run the sequential code}
Running code in multiple threads has some overhead.

\subsection{Measuring Project Success}
% How will I know if the project is a success?
% How am I going to evaluate my solution to the problem?

I can evaluate the successfulness of my solution by measuring the speedup of parallelising the program vs the original serial code. I'll look at existing programs written in rust to see any real world impact.

\section{References}
\printbibliography[heading=none]

\end{document}
