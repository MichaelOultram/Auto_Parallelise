\chapter{Conclusion}
The problem that I wanted to tackle was automatically converting sequential program into a parallelised program. This is a hard problem which is well established in the field of computer science. There are many different approaches explored in the literature, but I focused on converting the sequential source code automatically. Rust was chosen as the programming language used due to its memory management features and thread safety. Features of a parallelising compiler which would convert a sequential Rust program into a parallelised Rust program was designed and implemented using a compiler plugin. While this did give me all the information required for dependency analysis, it was very complicated and difficult to access. Using the compiler plugin required me to deal with all of the syntax sugar, dramatically increasing the number of cases I had to deal with. Most of the dependencies are detected by just looking at variables alone.

My implementation could be improved in many ways. Ordering external functions will fix some of the differences between the sequential and parallel program at the cost of forcing some dependencies that might not be necessary. Even with all the problems with my solution, I still managed to gain a speedup on the password cracker program. This shows that there is hope for the approach. If the changes that are described in \autoref{sec:discussion} are made then the parallelising compiler should be more consistent.
